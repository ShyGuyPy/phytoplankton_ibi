---
title: "pibi_long"
author: "Luke Vawter"
date: "December 21, 2018"
output: 
  html_document:
    df_print: paged
    toc: yes
    toc_depth: '6'
    toc_float: yes
---

####Download Packages
```{r load_packages, message=FALSE}
library(dplyr)
library(tidyr)
library(ggplot2)
library(purrr)
library(stringr)
library(leaflet)
library(lubridate)
library(readxl)
library(httr)
library(RCurl)
library(data.table)
library(jsonlite)
library(rprojroot)
library(ritis)
library(parallel)
```

mmir is Zach Smith's custom package
```{r}
library(mmir)
```


####Funcs and Variables
these varaible should be changed by the user as needed
```{r}
#this is the minimum date to be included
min_date = "1-1-2013"
#this is the minimum date to be included sdd the variable todays.date intot his variable if you want the most recent data
max_date = "12-31-2016"
```

variables and functions that will likely not be changed
```{r}
project.dir <- rprojroot::find_rstudio_root_file()

clean_string <- function(x) {
  x %>% 
    stringr::str_trim() %>% 
    tolower() %>% 
    stringr::str_replace_all("\\s+", " ") %>% 
    stringr::str_replace_all(" ", "_") %>%  
    if_else(. == "", as.character(NA), .)
}

clean_up <- function(x) {
  x %>% 
    rename_all(clean_string) %>% 
    mutate_if(is.character, funs(clean_string))%>% 
    distinct()
}

url.root <- "http://datahub.chesapeakebay.net/api.JSON"
todays.date <- format(Sys.Date(), "%m-%d-%Y")


dir.create(file.path(project.dir, "data/VA_ODU/"),
           recursive = TRUE, showWarnings = FALSE)

dir.create(file.path(project.dir, "data/CEDR/"),
           recursive = TRUE, showWarnings = FALSE)

dir.create(file.path(project.dir, "data/MD_DNR/"),
           recursive = TRUE, showWarnings = FALSE)

dir.create(file.path(project.dir, "data/water_quality"),
           recursive = TRUE, showWarnings = FALSE)


station.vec <- file.path(url.root,
                       "LivingResources",
                       "TidalPlankton",
                       "Reported",
                       min_date,
                       # "1-1-2013",
                       max_date, 
                       # "12-31-2016",
                       "17",
                       "Station") %>% 
  fromJSON() %>% 
  pull(unique(MonitoringLocationId))
```

####CEDR data



this pulls the sample and event data from cedr
```{r}
phyto.df <- file.path(url.root,
                      "LivingResources",
                      "TidalPlankton",
                      "Reported",
                       min_date,
                       # "1-1-2013",
                       max_date, 
                       # "12-31-2016",
                      "17",
                      "Station",
                      paste(station.vec, collapse = ",")) %>%
  fromJSON() %>% 
  clean_up()




dir.create(file.path(project.dir, "data/CEDR"),
           recursive = TRUE, showWarnings = FALSE)
phyto.df %>% 
  mutate(reportingvalue = as.character(reportingvalue)) %>% 
data.table::fwrite(file.path(rprojroot::find_rstudio_root_file(), "data/CEDR", "cedr_phyto_taxa.csv"))





event.df <- file.path(url.root,
                      "LivingResources",
                      "TidalPlankton",
                      "MonitorEvent",
                       min_date,
                       # "1-1-2013",
                       max_date, 
                       # "12-31-2016",
                      "17",
                      "Station",
                      paste(station.vec, collapse = ",")) %>%
  fromJSON() %>% 
  clean_up()





dir.create(file.path(rprojroot::find_rstudio_root_file(), "data/CEDR"),
           recursive = TRUE, showWarnings = FALSE)

data.table::fwrite(event.df, file.path(rprojroot::find_rstudio_root_file(), "data/CEDR", "cedr_phyto_event.csv"))
```

### Read csv's t dataframes

CEDR
```{r}
phyto.df <- data.table::fread(file.path(project.dir, "data/CEDR/", "cedr_phyto_taxa.csv")) %>% clean_up() %>% mutate(sampledate=as.Date(sampledate))

event.df <- data.table::fread(file.path(project.dir, "data/CEDR/", "cedr_phyto_event.csv")) %>% clean_up() %>% mutate(sampledate=as.Date(sampledate))

```

####water quality data

download water quality data:
```{r}
wq.df <- file.path(url.root,
                   "WaterQuality",
                   "WaterQuality",
                   format(min(phyto.df$sampledate) - days(3), "%m-%d-%Y"),
                   format(max(phyto.df$sampledate) + days(3), "%m-%d-%Y"), 
                   "6",
                   "7,16,23,24",
                   "station",
                   paste(station.vec, collapse = ","),
                   "21,34,74,83") %>% 
  fromJSON() %>% 
  clean_up()

```


```{r}
data.table::fwrite(wq.df, file.path(project.dir, "data/water_quality", "cedr_wq.csv"))
```


```{r}
wq.df <- data.table::fread(file.path(project.dir, "data/water_quality/cedr_wq.csv"),
                            data.table = FALSE,
                           na.strings = c(""))
```

```{r}
wq_test.df <- wq.df %>%
  filter(!parameter %in% c("chla", "doc", "pheo", "salinity"))
```


this snippet of Zach's code removes any row flagged in the problem column(anything other than na)
28 items are removed from the list
```{r}
wq.df <- wq.df %>%
  filter(is.na(problem)#,
         #parameter %in% c("chla", "doc", "pheo", "salinity") ...removed because these are the only 4 parameters included so
         #the code doesn't actually do anything
         )

wq.df <- wq.df %>%
  select(station, sampledate, layer, depth, parameter, measurevalue) %>% #eventid,
  mutate(sampledate=as.Date(sampledate))
```

####Prep Event

```{r}
phyto.df <- phyto.df %>%
  mutate(sampledate = as.Date(sampledate))
```

```{r}
event.df <- event.df %>%
  mutate(sampledate = as.Date(sampledate))
```

this is Zach's code for use with use for (I believe) older data that uses older salzone designations,
it's doing nothing for our current data set (2013-2016)
```{r}
event.df <- event.df %>%
  mutate(sampledate = as.Date(sampledate),
         salzone = case_when(
           salzone %in% c("tf", "fe") ~ "f",
           salzone %in% c("m", "me") ~ "m",
           salzone %in% c("o", "oe") ~ "o",
           salzone %in% c("p", "pe") ~ "p",
           TRUE ~ as.character(NA)
         ))
```

```{r}
pdepth.df <- event.df %>%
  filter(layer %in% c("ap","wc")) %>%
  mutate(sampledate = as.Date(sampledate)) %>%
  select(station, sampledate, pdepth) %>%
  dplyr::distinct()
```

applies pdepth to water quality dataframe
(should be wq.df or wq_w_pdepth not stat_samp when fixed)
currently wq-9821
na pdepth wq values-2494
```{r}
wq_w_pdepth.df <- left_join(wq.df, pdepth.df, by = c("station", "sampledate"))
```

generates new dataframe with new parameter s_chla (539 items)
```{r}
s_chla.df <- wq_w_pdepth.df %>%
  filter(layer == "s", 
         parameter == "chla") %>% 
  unite(parameter, c("layer", "parameter"), remove = FALSE) %>%
  filter(depth <= pdepth) #%>%
  #filter(parameter=="s_chla")
```

extracting depth integrated dataframe for each parameter
note:doc has 559, and salinity 1578 items where all others have 665
```{r}
di_doc.df <- wq_w_pdepth.df %>%
  filter(depth <= pdepth) %>%
  filter(parameter=="doc") %>%

  group_by(station, sampledate) %>%
  mutate(avg_di_doc = mean(measurevalue, na.rm = TRUE)) %>%
  ungroup()

di_chla.df <- wq_w_pdepth.df %>%
  filter(depth <= pdepth) %>%
  filter(parameter == "chla") %>%

  group_by(station, sampledate) %>%
  mutate(avg_di_chla = mean(measurevalue, na.rm = TRUE)) %>%
  ungroup()

di_salinity.df <- wq_w_pdepth.df %>%
  filter(depth <= pdepth) %>%
  filter(parameter == "salinity") %>%

  group_by(station, sampledate) %>%
  mutate(avg_di_salinity = mean(measurevalue, na.rm = TRUE)) %>%
  ungroup()

di_pheo.df <- wq_w_pdepth.df %>%
  filter(depth <= pdepth) %>%
  filter(parameter == "pheo") %>%

  group_by(station, sampledate) %>%
  mutate(avg_di_pheo = mean(measurevalue, na.rm = TRUE)) %>%
  ungroup()
```

C-  need to apply this to all sample, date combos but want to review with Claire first
```{r}
# di_salinity.df <-di_salinity.df %>%
# 
#   mutate(salzone = case_when(
#     avg_di_salinity >0 & avg_di_salinity <= 0.5 ~ "F",
#     avg_di_salinity > .5 &  avg_di_salinity <= 5 ~ "O",
#     avg_di_salinity > 5 & avg_di_salinity <= 18 ~ "M",
#     avg_di_salinity > 18~ "P")
#   )
```

C- need to add s_chla as well but need to review process with Claire
```{r}
#wq_joined.df <- left_join(di_doc.df, di_chla.df,di_salinity.df,di_pheo.df, by = c("station", "sampledate"))
wq_all.df <- Reduce(function(x, y) merge(x, y, all=TRUE), list(di_doc.df, di_chla.df,di_salinity.df,di_pheo.df))
```

```{r}
# wq_sz.df <- wq_all.df %>%
#   select(station, sampledate, salzone) %>%
#   distinct() %>%
#   filter(!is.na(salzone))
```

```{r}
# sal.df <- wq_all.df %>%
#   group_by(station, sampledate) %>%
#   mutate(apple= case_when(parameter == "salinity"~avg_di_salinity, 
#                           parameter %in% c("pheo", "doc", "chla")~0)
#          ) %>%
#   summarise(apple = max(apple)) %>%
#   ungroup() 
# 
# wq_sal.df <- left_join(wq_all.df, sal.df, by = c("station", "sampledate"))
```

generate dataframe...
```{r}
sal.df <- wq_all.df %>%
  mutate(avg_di_salinity= case_when(parameter %in% c("pheo", "doc", "chla")~0, TRUE~avg_di_salinity)
         ) %>%
  filter(!is.na(avg_di_salinity))

sal.df <- sal.df %>%
  group_by(station, sampledate) %>%
  summarise(avg_di_salinity = max(avg_di_salinity)) %>%
  ungroup() 
```


```{r}
wq_all.temp<- wq_all.df %>%
  select(-avg_di_salinity)

#wq_all_test.df < left_join(wq_all.temp, sal.df, by = c("station", "sampledate"))
wq_all_test.df <- Reduce(function(x, y) merge(x, y, all=TRUE), list(wq_all.temp, sal.df))
  
```

```{r}
wq_all_test.df <-wq_all_test.df %>%

  mutate(salzone = case_when(
    avg_di_salinity >0 & avg_di_salinity <= 0.5 ~ "F",
    avg_di_salinity > .5 &  avg_di_salinity <= 5 ~ "O",
    avg_di_salinity > 5 & avg_di_salinity <= 18 ~ "M",
    avg_di_salinity > 18~ "P")
  )
```


###Taxanmoic data (ITIS)

this is Zach's code.  It's pretty neat.
```{r}
col.class.vec <- c("samplenumber" = "character",
                   "tsn" = "character",
                   "speccode" = "character",
                   "reportingvalue" = "integer")

bay.temp <- data.table::fread(file.path(project.dir,  "data/CEDR/cedr_phyto_taxa.csv"
                                        #"data/phytoplankton2/VA_ODU_phyto_taxa.csv"
                                        ),
                            data.table = FALSE,
                            colClasses = col.class.vec)
```

this test shows that 1794 have a tsn of 0(Zach explains there are no na, only 0, which is annoying)
```{r}
need_tsn.df <- bay.temp %>%
  filter(tsn==0)
```

tsn assignment code(reduces number of tsn not assinged to 1514 from 1794)
```{r}
taxa.df <- bay.temp %>% 
  mutate(
    tsn = as.integer(tsn),
    tsn = case_when(
      latinname == "navicula_notablis" ~ as.integer(4327),
      latinname == "pleurosigma_macrum" ~ as.integer(4650),
      latinname == "pleurosigma_obscurum" ~ as.integer(591383),
      latinname == "polykrikos_hartmannii" ~ as.integer(331299),
      latinname == "protoperidinium_aciculiderum" ~ as.integer(10329),
      latinname == "protoperidinium_paulseni" ~ as.integer(3568),
      latinname == "scrippsiella_favionese" ~ as.integer(10537),
      latinname == "tetrastrum_caudatum" ~ as.integer(5691),
      latinname == "didymocystis" ~ as.integer(5810),
      latinname == "lauterborniella_elegantissima" ~ as.integer(6097),
      latinname == "characium_sp." ~ as.integer(5756),
      latinname == "cylindrospermopsis_sp." ~ as.integer(203689),
      latinname == "chaetoceros_neogracilis" ~ as.integer(1004011),
      latinname == "navicula_retusa_cancellata" ~ as.integer(1020372),
      latinname == "karlodinium_micrum" ~ as.integer(180904),
      latinname == "lagerheimia" ~ as.integer(6017),
      latinname == "quadricoccus_euryhalinicus" ~ as.integer(957939),
      latinname == "scrippsiella_precaria" ~ as.integer(10536),
      latinname == "psuedosolenia_calcar-avis" ~ as.integer(970064),
      latinname == "centronella" ~ as.integer(970064),
      latinname == "amphidinium_tatrae" ~ as.integer(9997),
      latinname == "navicula_lata" ~ as.integer(4450),
      latinname == "nitzschia_vitrea_recta" ~ as.integer(5204),
      latinname == "rhaphoneis_gemmifera" ~ as.integer(3145),
      latinname == "delphineis_surirella" ~ as.integer(969978),
      latinname == "navicula_annulata" ~ as.integer(3649),
      latinname == "proboscia_alata_gracillima" ~ as.integer(610099),
      latinname == "guinardia_striata" ~ as.integer(2921),
      latinname == "guinardia_cylindrus" ~ as.integer(2921),
      latinname == "aphanizomenon_issatschenkoi" ~ as.integer(1191),
      latinname == "helicotheca_tamesis" ~ as.integer(590815),
      latinname == "corethron_valdivae" ~ as.integer(2386),
      latinname == "gonyaulax_conjuncta" ~ as.integer(10359),
      latinname == "lioloma_delicatulum" ~ as.integer(573597),
      latinname == "syracosphaera_histrica" ~ as.integer(2234),
      latinname == "rhizosolenia_formosa" ~ as.integer(2879),
      latinname == "proboscla_alata_curvirostris" ~ as.integer(610099),
      latinname == "membraneis_challengeri" ~ as.integer(3648),
      latinname == "chrysococcus_tesselatus" ~ as.integer(1751),
      latinname == "rhoicosphenia_abbreviata" ~ as.integer(3633),
      latinname == "protoperidinium_aciculiferum" ~ as.integer(10340),
      latinname == "protoperidinium_fimbriatum" ~ as.integer(10340),
      latinname == "licmophora_inflata" ~ as.integer(3155),
      latinname == "biddulphia_reticulata" ~ as.integer(2678),
      latinname == "caloneis_lepidula" ~ as.integer(4369),
      latinname == "caloneis_trinodis" ~ as.integer(4369),
      latinname == "amphiprora_cholnokyi" ~ as.integer(4674),
      latinname == "navicula_interrupta" ~ as.integer(3649),
      latinname == "cerataulus_radiatus" ~ as.integer(2709),
      latinname == "gyrosigma_balticum_silimis" ~ as.integer(4623),
      latinname == "dictyocha_siderea" ~ as.integer(1804),
      latinname == "odontella_alternans" ~ as.integer(573604),
      latinname == "nitzschia_vitrea_salinarum" ~ as.integer(5204),
      latinname == "proboscla_alata_indica" ~ as.integer(610099),
      latinname == "attheya_decora" ~ as.integer(2876),
      latinname == "synedra_closterioides" ~ as.integer(970065),
      latinname == "trinacria_regina" ~ as.integer(2747),
      latinname == "chattonella" ~ as.integer(969917),
      latinname == "chattonella_subsalsa" ~ as.integer(969917),
      latinname == "heterosigma_akashiwo" ~ as.integer(969917),
      latinname == "vibrio_fisheri" ~ as.integer(959178),
      TRUE ~ as.integer(tsn)
    )
  )
```

```{r}
taxa_need_tsn.df <- taxa.df %>%
  filter(tsn==0)
``` 

changed all org_tsn references to tsn, because org_tsn does not exist in bay.temp.
Also, first row is na's and 0's suggesting that the data has a space between the header, and that total number of
ojects(3065) may be one over our actual values
```{r}
hier.wide <- lapply(unique(bay.temp$tsn), function(tsn.i) {
 #print(tsn.i)
  
  if(ncol(usage(tsn.i)) == 0) return(data.frame(tsn = as.integer(tsn.i),
                                                stringsAsFactors = FALSE))
  if(!ritis::usage(tsn.i)$taxonUsageRating %in% c("accepted", "valid")) {
    tsn.accepted <- ritis::accepted_names(as.integer(tsn.i))$acceptedTsn
  } else {
    tsn.accepted <- as.integer(tsn.i)
  }

  full.df <- ritis::hierarchy_full(tsn.accepted) %>%
    select(rankname, taxonname, tsn) %>%
    slice(1:which(tsn == tsn.accepted)) %>%
    mutate(tsn = as.integer(tsn.i),
           final_tsn = as.integer(tsn.accepted),
           final_id = slice(., which(tsn == tsn.accepted))$taxonname)
}
) %>%
  bind_rows() %>%
#   select(-tsn) %>% 
  #spread(rankname, taxonname) %>%
  clean_up()
```

removes the gap mentioned above
```{r}
hier.wide<- hier.wide %>%
  filter(!is.na(taxonname) & !is.na(rankname))
```

```{r}
column.vec <- c("org_tsn", "final_tsn", "final_id",
                "kingdom", "subkingdom", "infrakingdom", 
                "superdivision", "division", "subdivision", "infradivision",
                "superphylum", "phylum", "subphylum", "infraphylum", 
                "superclass", "class", "subclass", "infraclass", 
                "superorder", "order", "suborder", "infraorder", 
                "superfamily", "family", "subfamily", 
                "tribe", "subtribe", 
                "genus", "subgenus", 
                "species", "subspecies")

column.vec <- column.vec[column.vec %in% names(hier.wide)]
```

```{r}
dir.create(file.path(project.dir, "data/itis"),
           recursive = TRUE, showWarnings = FALSE)

data.table::fwrite(hier.wide, file.path(rprojroot::find_rstudio_root_file(), "data/itis", "itis_hierarchy.csv"))
```


####Testing
```{r}
# na <- stat_samp %>%
#   filter(is.na(stat_samp$pdepth))
# 
# not_na <- stat_samp %>%
#   filter(!is.na(stat_samp$pdepth))
```


---
title: "Calculating the Phytoplankton Index of Biotic Integrity (PIBI)"
date: "February 24, 2020"
author:
  - name: "Luke C. Vawter, lvawter@icprb.org"
    affiliation: Interstate Commission on the Potomac River Basin
  - name: "Zachary M. Smith, zachary.smith2@dec.ny.gov"
    affiliation: New England Interstate Water Pollution Control Commission
  - name: "Rikke Jepsen, rjepsen@icprb.org"
    affiliation: Interstate Commission on the Potomac River Basin
output:
  html_document:
    df_print: paged
    toc: true
    toc_depth: 4
    toc_float:
      collapsed: true
---
###**Introduction**
The Phytoplankton Index of Biotic Integrity (PIBI) was developed by Lacouture et al. (2006) for spring and summer phytoplankton samples in each of the four salinity zones (fresh water, polyhaline, mesohaline, oligohaline) of the Chesapeake Bay and its tidal tributaries. Twelve metrics are used to quantify the status of phytoplankton communities relative to water quality, and a narrative rating is assigned to the resulting scores, ranging from "poor" to "good." IBIs, such as the PIBI, are intended to be used as a management tool to evalaute the status of biological communities. 

The R-scripts contained in this document describe steps needed to calculate the PIBI, following the methodology outlined by Lacouture et al. (2006), with additional references from documentation written by former ICPRB staff member, Jacqueline M. Johnson. The code chunks are designed to be copied and pasted into the RStudio editor. In order to keep the scripts organized, it is suggested that the corresponding section header is added and commented out using `#`. The phytoplankton data used are extracted from the Chesapeake Bay Program's Chesapeake Environmental Data Repository (CEDR) using an Application Programming Interface (API).

###**Working With RStudio**  
RStudio must be installed on your computer to implement the following R scripts. If RStudio is not installed, it can be downloaded for free from [https://www.rstudio.com/](https://www.rstudio.com/). This [webpage](https://courses.edx.org/courses/UTAustinX/UT.7.01x/3T2014/56c5437b88fa43cf828bff5371c6a924/) details the short installation process. Once RStudio is ready to be used on your computer, copy and paste the scripts into the RStudio editor and run them. Each time a dataframe is created, it can be viewed by typing `View(name)` in the console or by clicking its name in the Environment tab on the right.          

Some helpful R resources are listed below for those new to RStudio:

* The R Book by Michael J. Crawley  
* R for Data Science by Hadley Wickham and Garrett Grolemund (https://r4ds.had.co.nz/index.html)
* Data Camp's free Introduction to R course (https://www.datacamp.com/courses/free-introduction-to-r)
* An Introduction to R by W.N. Venables, D.M. Smith and the R Core Team   (https://cran.r-project.org/doc/manuals/R-intro.pdf)  
* Tutorials Point (https://www.tutorialspoint.com/r/r_overview.htm)  
* Stack Overflow for asking questions or reading answers to posted questions   

###**Setup** 
####**Directories**
You will need to create a directory (series of folders) to house the inputs and outputs of this program, as follows:

1. Create a new folder (referred to as the "main" folder below) with any name you choose. This will house the main directory structure.
2. Within the main folder, create an RStudio project. To create the Project, open RStudio and navigate to File > New Project. Save the project in the main folder with any name you choose. 
3. Open the RProject and create a new RScript (File > New File > R Script), named as you like and also saved to the main folder.
4. Also in the main folder, create a new folder named "data". Inside the "data" folder, create five new folders, with the names copied exactly:
    + "carbon" (with carbon_list_2014.csv inside)
    + "Jackie" (with JMJ_PIBI_Salzone_data.xlsx inside)
    + "CEDR"   (empty for now)
    + "water_quality" (empty for now)
    + "ScoresRatings" (empty for now)

####**Load Packages**
The following packages must be installed and loaded into the environment.
```{r message=FALSE, warning=FALSE}
library(dplyr)
library(tidyr)
library(data.table)
library(lubridate)
library(readxl)
library(jsonlite)
library(rprojroot)
library(ritis)
library(stringr)
library(purrr)
library(lubridate)
library(parallel)
```
####**Establish API Variables**
The variables below represent values found in the Bay Program's API guide. Unless changes occur to the API's structure, these variables will not need to be altered.

  + pico_num = picoplankton
  + phyto_num = phytoplankton
  + chla = chlorophyll a
  + doc = dissolved organic carbon
  + pheo = pheophytin
```{r}
pico_num = "18"
phyto_num = "17"

chla = 21
doc = 34 
pheo = 74 
salinity = 83
```
####**Establish Directory**
Data for this document are located in various files. The object `project.dir` represents the phytoplankton project directory and will be used as the root of the file path throughout the document.
```{r}
project.dir <- rprojroot::find_rstudio_root_file()
```
####**Custom Functions** 
Two custom functions will be used, but must first be established. Begin with establishing the `clean_string()` function. It modifies character objects by 1) removing leading and trailing white spaces, 2) converting all characters to lowercase, and 3) replacing all spaces with an underscore. These corrections eliminate common typos and standardize character objects.

Then, establish the `clean_up()` function, a wrapper for `clean_string()`. This function applies `clean_string()` to the column headers and character columns of data frames to standardize character values and make it easier to work with the data.
```{r}
clean_string <- function(x) {
  x %>% 
    stringr::str_trim() %>% 
    tolower() %>% 
    stringr::str_replace_all("\\s+", " ") %>% 
    stringr::str_replace_all(" ", "_") %>%  
    if_else(. == "", as.character(NA), .)
}

clean_up <- function(x) {
  x %>% 
    rename_all(clean_string) %>% 
    mutate_if(is.character, funs(clean_string)) %>% 
    distinct()
}
```
####**Set Date Range**
Create `url.root`, which represents the root of the CEDR API. All API calls will start with `url.root`. Additionally, use `Sys.Date()` to find today's date, which will be used in the API query. This makes the following script more dynamic because if this script is run in the future, the imported dataset will include any data that was added to the CEDR database after the initial data pull.

Use `min_date` and `max_date` to set the date range of the data you want to download. Note that ending date can be set to `todays.date` if you want to extract the most current data every time you run the download code. Also note that the format of the date input into these variables must match with the examples in place below (`mm-dd-yyyy`). 
```{r}
url.root <- "http://datahub.chesapeakebay.net/api.JSON"
todays.date <- format(Sys.Date(), "%m-%d-%Y")

# The earliest data to be extracted from CEDR. Change the current date (January 1, 1970) to your desired starting date. 
min_date = "01-01-1970"

# The latest date to be extracted from CEDR. Either use a date (mm-dd-yyyy) or use `todays.date` for the most recent data.
max_date = todays.date
```
###**Data Acquisition**
####**Download Station Vector**
Create a vector of stations (`station.vec`) that contains phytoplankton data. The vector will be used to query data from the CEDR API in subsequent code chunks.
```{r}
station.vec <- file.path(url.root,
                       "LivingResources",
                       "TidalPlankton",
                       "Reported",
                       min_date,
                       max_date, 
                       phyto_num,
                       "Station") %>% 
  fromJSON() %>% 
  pull(unique(MonitoringLocationId))
```
####**Download Phytoplanton Data**
Download all of the phytoplankton data from the CEDR API. Then, the data are exported to the CEDR folder as a CSV.
```{r warning=FALSE, error=FALSE}
phyto.df <- file.path(url.root,
                      "LivingResources",
                      "TidalPlankton",
                      "Reported",
                       min_date,
                       max_date, 
                       phyto_num,
                       "Station",
                       paste(station.vec, collapse = ",")) %>%
  fromJSON() %>% 
  clean_up()

phyto.df <- phyto.df %>% 
  mutate(reportingvalue = as.character(reportingvalue)) %>% 
data.table::fwrite(file.path(project.dir, "data/CEDR", "cedr_phyto_taxa.csv"))
```
####**Download Monitoring Event Data**
Download all of the monitoring event data associated with the collection of phytoplanton from the CEDR API. This may take several minutes. Once the data pull is finished, the data are exported to the CEDR folder as a CSV, "cedr_phyto_event.csv". 
```{r}
event.df <- file.path(url.root,
                      "LivingResources",
                      "TidalPlankton",
                      "MonitorEvent",
                      min_date,
                      max_date, 
                      phyto_num,
                      "Station",
                      paste(station.vec, collapse = ",")) %>%
  fromJSON() %>% 
  clean_up()

data.table::fwrite(event.df, file.path(project.dir, "data/CEDR", "cedr_phyto_event.csv"))
```
####**Download Station Information**
Download all of the station data associated with the collection of phytoplankton from the CEDR API. Then, the data are exported to the CEDR folder as a CSV, "cedr_pico_taxa.csv".
```{r}
pico.df <- file.path(url.root,
                      "LivingResources",
                      "TidalPlankton",
                      "Reported",
                      min_date,
                      max_date, 
                      pico_num,
                      "Station",
                      paste(station.vec, collapse = ",")) %>%
  fromJSON() %>% 
  clean_up()

pico.df <- pico.df %>% 
  mutate(reportingvalue = as.character(reportingvalue)) %>% 

data.table::fwrite(file.path(project.dir, "data/CEDR/", "cedr_pico_taxa.csv"))
```
####**Download Water Quality Data**
Download chlorophyll a, dissolved organic carbon, and pheophytin water quality data collected from the same stations as the phytoplankton data. Then, the data are exported to the CEDR folder as a CSV, "cedr_wq.csv". 

In some cases, the water quality data was not collected on the same day as the phytoplankton data. To obtain more phytoplankton sampling events with associated water quality data, Lacouture et al. (2006) used water quality data collected within ± 3 days of the phytoplankton sample date. The first step of this, so-called, 3-day window is to identify the 3 days prior to and after the sampling date.  
```{r}
wq.df <- file.path(url.root,
                   "WaterQuality",
                   "WaterQuality",
                   format(as.Date(min(event.df$sampledate)) - days(3), "%m-%d-%Y"),
                   format(as.Date(max(event.df$sampledate)) + days(3), "%m-%d-%Y"),
                   "6",  
                   "7,23",
                   "station",
                   paste(station.vec, collapse = ","),
                   paste(
                     chla,doc,pheo,salinity, sep=",")) %>%
  fromJSON() %>% 
  clean_up()

data.table::fwrite(wq.df, file.path(project.dir, "data/water_quality", "cedr_wq.csv"))
```
Load the CSV files containing the CEDR data that were acquired using the API.  
```{r}
phyto.df <- data.table::fread(file.path(project.dir, "data/CEDR/", "cedr_phyto_taxa.csv"), stringsAsFactors = FALSE) %>% 
  clean_up() %>% 
  mutate(sampledate=as.Date(sampledate))

event.df <- data.table::fread(file.path(project.dir, "data/CEDR/", "cedr_phyto_event.csv"), stringsAsFactors = FALSE) %>% 
  clean_up() %>%
  mutate(sampledate=as.Date(sampledate))

pico.df <- data.table::fread(file.path(project.dir, "data/CEDR/", "cedr_pico_taxa.csv"), stringsAsFactors = FALSE) %>% 
  clean_up() %>%
  mutate(sampledate=as.Date(sampledate))

wq.df <- data.table::fread(file.path(project.dir, "data/water_quality/cedr_wq.csv"), stringsAsFactors = FALSE, data.table = FALSE, na.strings = c("")) %>% 
  clean_up()
```
All of the water quality samples from the same station, within ± 3 days, are found for each station and sample date combination (each row). If there are multiple water quality subsamples within the 3-day window, the sample collected closest to the phytoplankton data is retained. There is a possibility that water quality samples could be collected at equal intervals before and after phytoplankton sampling. For example, water quality samples could have been collected one day before and one day after phytoplankton sampling. In those instances, the sample collected prior to the phytoplankton sampling is selected.
```{r}
event.sub <- event.df %>%
  select(station, sampledate) %>%
  distinct() %>%
  mutate(sampledate = as.Date(sampledate)) %>%
  mutate(lower_date = sampledate - lubridate::days(3),
         upper_date = sampledate + lubridate::days(3))

wq.df <- wq.df %>%
  mutate(sampledate = as.Date(sampledate))

n.cores <- detectCores() - 1
cl <- makeCluster(n.cores)
clusterExport(cl = cl, varlist = c("wq.df", "event.sub"))
clusterEvalQ(cl, c(library(dplyr))) %>% invisible()

env.df <- parLapply(cl, 1:nrow(event.sub), function(row.i) {

  sub.df <- slice(event.sub, row.i)
  #----------------------------------------------------------------------------
  sub.env <- wq.df %>%
    filter(station == sub.df$station,
           sampledate >= sub.df$lower_date,
           sampledate <= sub.df$upper_date
           )
  #----------------------------------------------------------------------------
  if (nrow(sub.env) == 0) return(data.frame(
    station = NA,
    sampledate = NA,
    parameter = NA,
    measurevalue = NA
  ))
  #----------------------------------------------------------------------------
  final.df <- sub.env %>%
    mutate(date_diff = sampledate - sub.df$sampledate,
           abs_date_diff = abs(date_diff),
           sampledate = sub.df$sampledate) %>%
    filter(abs_date_diff == min(abs_date_diff))
  #----------------------------------------------------------------------------
  if (nrow(final.df) > 1) {
    final.df <- final.df %>%
      filter(sampledate == min(sampledate))
  }
  #----------------------------------------------------------------------------
  return(final.df)

}) %>%
  bind_rows() %>%
  filter(!is.na(station))

stopCluster(cl)

event.df <- left_join(event.df, env.df, by = c("station", "sampledate"))

event.df <- event.df %>%
  mutate(source = source.x, sampletype = sampletype.x, layer = layer.x, latitude = latitude.x, longitude = longitude.x, totaldepth = totaldepth.x, sampletime = sampletime.x) %>%
  select( -source.x, -source.y, -sampletype.x, sampletype.y, -layer.x, layer.y, -latitude.x, -latitude.y, -longitude.x, -longitude.y, -totaldepth.x, -totaldepth.y, -sampletime.x, -sampletime.y)
```
Create a unique ID for phytoplankton sampling events and water quality events. The ID is a concatenation of the station and sample date. Then, create a vector to store the concatinated IDs from the phytoplankton sampling events and include only the water quality data that have a matching ID with phytoplankton events. Finally, select a subset of the columns from the water quality data.
```{r}
phyto.df <- phyto.df %>%
  mutate( sampledate =  as.Date(sampledate)) %>%
  mutate(concat = paste0(station, sampledate))

wq.df <- wq.df %>%
  mutate( sampledate =  as.Date(sampledate)) %>%
  mutate(concat = paste0(station, sampledate))

concat_vector <- pull(phyto.df, concat)

wq.df <-wq.df %>%
  filter(concat %in% concat_vector) 

wq.df <- wq.df %>%
  select(station, sampledate, layer, depth, parameter, measurevalue, eventid) %>% 
  mutate(sampledate=as.Date(sampledate))
```
###**Prepare Event Data**
Convert the sample dates from both phytoplankton data and the event data to the correct date format. Then, filter data so that only samples taken above the pycnocline and in the water column are included, keeping only the relevant columns. Next, join the selected event data to the water quality data. Now the dataframe contains water quality information with pycnocline depth (pdepth) data. Subsequently, determine if the phytoplankton sample depth is above the pdepth, and filter out data with a depth at or below the pdepth. 
```{r}
phyto.df <- phyto.df %>%
  mutate(sampledate = as.Date(sampledate))

event.df <- event.df %>%
  mutate(sampledate = as.Date(sampledate))

pdepth.df <- event.df %>%
  filter(layer %in% c("ap","wc")) %>%
  select(station, sampledate, pdepth) %>%
  dplyr::distinct()

wq_w_pdepth.df <- left_join(wq.df, pdepth.df, by = c("station", "sampledate"))

wq_w_pdepth.df <- wq_w_pdepth.df %>%
  mutate(above_pdepth = case_when(depth <= pdepth ~"Yes",
                                  depth > pdepth & station %in% c("ret3.1","ret4.3","ret3.1") ~"No, but RET",
                                  depth > pdepth ~"No"))

wq_above_pdepth.df <- wq_w_pdepth.df %>%
  filter(depth <= pdepth) 

wq_above_pdepth.df <- wq_w_pdepth.df %>%
  filter(depth <= pdepth) 

test_wq_above_pdepth.df <- wq_above_pdepth.df %>%
  filter(station == "cb3.3c" & sampledate=="1986-04-08")
```
Check for missing data, i.e., station and date combinations that are present in `event.df` but are not represtented in `wq_above_pdepth.df` using the `find_missing` function.
```{r}
find_missing <- function(data_backbone, source_data, modified_data, step_vector) {
  missing.df <- anti_join(data_backbone, modified_data, by = c("station","sampledate"))
  
  missing.df <-  missing.df %>%
    mutate( sampledate =  as.Date(sampledate)) %>%
    mutate(concat = paste0(station, sampledate))
  
  source_data <- source_data %>%
    mutate( sampledate =  as.Date(sampledate)) %>%
    mutate(concat = paste0(station, sampledate))
  
  concat_vector2.vec <- pull(missing.df, concat)
  
  missing_full.df <-source_data %>%
    filter(concat %in% concat_vector2.vec) 
  
  modified_data <- modified_data %>%
  mutate( sampledate =  as.Date(sampledate)) %>%
  mutate(concat = paste0(station, sampledate))

  final.df <- full_join(modified_data, missing_full.df, by = step_vector)

  return(final.df)
}

# Show the mssing values:
name_missing <- function(data_backbone, source_data, modified_data, step_vector) {
  missing.df <- anti_join(data_backbone, modified_data, by = c("station","sampledate"))
  
  missing.df <-  missing.df %>%
    mutate( sampledate =  as.Date(sampledate)) %>%
    mutate(concat = paste0(station, sampledate))
  
  source_data <- source_data %>%
    mutate( sampledate =  as.Date(sampledate)) %>%
    mutate(concat = paste0(station, sampledate))
  
  concat_vector2.vec <- pull(missing.df, concat)
  
  final.df <-source_data %>%
    filter(concat %in% concat_vector2.vec) 
  
    return(final.df)
}

find_missing_apdepth.vec <- c("station", "sampledate", "layer", "pdepth", "concat", "depth", "parameter", "measurevalue", "above_pdepth", "eventid")

wq_above_pdepth.df <- find_missing(event.df, wq_w_pdepth.df, wq_above_pdepth.df, find_missing_apdepth.vec)
```
Generate a new dataframe with surface chloraphyll a (s_chla) data, and average the replicates from `s_chla.df` to get an average value of surface chlorophyll a and generate a depth-integrated surface chlorophyll a. Then, export the entries with errors to the "water_quality" folder as a CSV ("cb3.3c_mutants.csv"). These are entries that are likely reporting errors stemming from a known issue with station cb3.3c between 1986 and 1991, where a second entry was taken that was vastly different from the first.
```{r}
s_chla.df <- wq_above_pdepth.df %>%
  filter(layer == "s", 
         parameter == "chla") %>% 
  unite(parameter, c("layer", "parameter"), remove = FALSE)

di_s_chla.df <- s_chla.df %>%
  group_by(station, sampledate, depth) %>%
  mutate(measurevalue_averaged = mean(measurevalue)) %>%
  distinct(station, sampledate, depth, eventid, layer, parameter, measurevalue_averaged, concat) %>%
  ungroup()

mutants <- di_s_chla.df %>%
  group_by(concat) %>%
  filter(station == "cb3.3c" & measurevalue_averaged > 100 & n() >1) %>%
  data.table::fwrite(file.path(project.dir, "data/water_quality", "cb3.3c_mutants.csv"))  

# Address issues with station cb3.3c. Group by station and average the dupliacte entries, disregarding mutant entries by turning them into zeros.
di_s_chla.df <- di_s_chla.df %>%  
  group_by(concat) %>%
  mutate(test=n()) %>%
  mutate(measurevalue_averaged = case_when(test > 1 & station == "cb3.3c" & measurevalue_averaged > 100~0, 
                                           TRUE ~ measurevalue_averaged)) %>%
  mutate( measurevalue_averaged =(case_when(test > 1 ~ mean(measurevalue_averaged),
                                            TRUE ~ measurevalue_averaged))) %>%

  select(-test) %>%
  ungroup() %>%
  distinct(station, sampledate, layer, parameter, measurevalue_averaged, concat) 
```
Find missing values in `di_s_chla.df` and join them to the dataframe. Then average the sample replicates and the depth-integrated water quality values. 
```{r}
find_missing_schla.vec <- c("station", "sampledate", "layer", "concat", "depth", "parameter", "eventid")

missing_s_chla.df <- name_missing(event.df, wq_above_pdepth.df, di_s_chla.df, find_missing_schla.vec) %>%
    distinct(eventid, station, sampledate, concat) %>%
  mutate(parameter = "s_chla") %>%
  mutate(sampledate = as.Date(sampledate)) %>%
  mutate()

di_s_chla.df <- full_join(di_s_chla.df, missing_s_chla.df, by = c("station", "sampledate", "parameter", "concat")) 

wq_above_pdepth.df <- wq_above_pdepth.df %>%
  group_by(station, sampledate, depth, parameter) %>%
  mutate(measurevalue_averaged = mean(measurevalue)) %>%
  distinct(station, sampledate, depth, parameter, measurevalue_averaged) %>%
  ungroup()

wq_above_pdepth.df <- wq_above_pdepth.df %>%
  group_by(station, sampledate, parameter) %>%
  mutate(depth_integrated_value = mean(measurevalue_averaged)) %>%
  distinct(station, sampledate, depth_integrated_value) %>%
  ungroup()
```
Join surface chloraphyll data to the water quality data. Next, assign a season of either spring or summer to dates between March-May and July-September, respectively. Then, assign salinity zones (salzones) to each sample.

*F = Fresh water
*O = Oligohaline
*M = Mesohaline
*P = Polyhaline
```{r}
di_s_chla.df <- di_s_chla.df %>% 
  rename(depth_integrated_value = measurevalue_averaged)

wq_all.df <- full_join(wq_above_pdepth.df, di_s_chla.df, by = c("station", "sampledate", "parameter", "depth_integrated_value"))

wq_warm.df <- wq_all.df %>%
  mutate(month = month(sampledate),
         season = case_when(
           month %in% c(3, 4, 5) ~ "spring",
           month %in% c(7, 8, 9) ~ "summer",
           TRUE ~ "remove"
          )) 

wq_sal.df <- wq_warm.df %>%
  filter(parameter == "salinity")

wq_sal.df <- wq_sal.df %>%
  mutate(salzone = case_when(
    parameter == "salinity" & depth_integrated_value > 0 & depth_integrated_value <= 0.5 ~ "F",
    parameter == "salinity" & depth_integrated_value > 0.5 &  depth_integrated_value <= 5 ~ "O",
    parameter == "salinity" & depth_integrated_value > 5 & depth_integrated_value <= 18 ~ "M",
    parameter == "salinity" & depth_integrated_value > 18 ~ "P")) %>%
    mutate(concat = paste0(station, sampledate)) 

wq_sal_id.df <- wq_sal.df %>%
  distinct(concat, salzone)

wq_warm.df <- wq_warm.df %>%
    mutate(concat = paste0(station, sampledate))   

wq_warm_sal.df <- left_join(wq_warm.df, wq_sal_id.df, by = c("concat"))
```
Find events without salinity data and assign a salinity value when possible. Some samples can be assigned as Fresh Water (F), based on known salinity profiles. Add these assigned salzones to the main dataframe. Then, import the salinity zone used by Jacqueline M. Johnson of the Chesapeake Bay Program. This will provide a check of salinity zone classification from 10 years ago to the salinity zone classification in CEDR.NOTE: a message starting with "Joining, by = ..." may appear when this code chunk is run. This is not an error, and you can proceed with the scripts without issue. Once the salzones have been joined, convert the dataframe from long to wide format and remove winter and autumn samples.
```{r message=FALSE, warning=FALSE}
wq_no_sal.df <- anti_join(wq_warm_sal.df, wq_sal_id.df, by = c("concat"))

wq_sal_fill.df <-  wq_no_sal.df %>%
  distinct(concat, station, sampledate, season, salzone) %>%
  mutate(salzone = case_when((station %in% c("cb1.1", "tf2.3", "tf4.2","tf5.5" ) & is.na(salzone)) | (season == "spring" & station %in% c("et5.1", "tf1.5") & is.na(salzone))
         ~ "F", TRUE ~ salzone  ))

wq_sal_filled.df <- wq_sal_fill.df %>%
  filter(salzone == "F")

wq_warm_sal_added.df <- left_join(wq_warm_sal.df, wq_sal_filled.df, by= c("concat", "salzone","station","sampledate", "season"))

jackie_salzones.df <- readxl::read_excel(file.path(project.dir, "data/Jackie/JMJ_PIBI_Salzone_Data.xlsx"), sheet = "JMJ Salzone+Scores") %>% 
  clean_up() %>%
  rename(salzone = ibi_salzone)

jackie_salzones.df <-  jackie_salzones.df %>%
  mutate(concat = paste0(station, sample_date)) 

wq_need_sal.df <- wq_warm_sal_added.df %>%
  mutate(year = year(sampledate)) %>%
  filter(year >= 1984 & year <= 2011 & is.na(salzone))

jackie_salzones.df <- jackie_salzones.df %>%
  select(concat,salzone)

if (nrow(wq_need_sal.df) > 1) {
  wq_has_sal.df <- left_join(wq_need_sal.df, jackie_salzones.df, by= c("concat", "salzone"))

  anti_wq_warm_sal_added.df <- anti_join(wq_warm_sal_added.df, wq_has_sal.df, by= c("concat"))

  wq_warm_sal_added.df <- full_join(anti_wq_warm_sal_added.df, wq_has_sal.df)
}

wq_warm_sal_added.df <- wq_warm_sal_added.df %>%
  distinct()

wq_warm.wide <- wq_warm_sal_added.df %>%
  select(-layer, -eventid,-concat) %>% 
  spread(parameter, depth_integrated_value)

wq_final.df <- wq_warm.wide %>%
 filter(season %in% c("spring", "summer"))
```
###**Prepare Carbon Assignments**
A large but incomplete table of taxa size and carbon values is imported from the project data directory and reformatted so that it will join with the previously-formatted data. Next, import taxonomic data associated with phytoplankton data that was downloaded from CEDR. Then, filter the data so that only samples collected during spring and summer and above the pycnocline are kept. NOTE: a message stating "NAs introduced by coercion to integer range" may appear. This is not an error and you can proceed with the scripts. If there are multiple taxa with the same taxonomic name, then the reporting values should be summed. Each row should represent a unique taxon. Only phytoplankton data (“ph”) is retained for analysis. Additionally, some taxa were not identified to any useful taxonomic rank and are excluded from the analysis.
```{r warning=FALSE, message=FALSE}
carbon.df <- data.table::fread(file.path(project.dir, "data/carbon/", "carbon_list_2014.csv")) %>% 
  clean_up()

carbon.df <- carbon.df %>%
  mutate(tsn =  gsub("(?<![0-9])0+", "", tsn, perl = TRUE)) %>%
  rename(latinname = lbl) %>%
  rename(carbon = `carbon_(picogram_c_per_cell)`) %>%
  mutate(tsn = as.integer(tsn)) %>%
  mutate(size = case_when(size == "not_applicable"~ as.character(NA), TRUE ~size))

col.class.vec <- c("samplenumber" = "character", "tsn" = "character", "speccode" = "character")

taxa.raw <- data.table::fread(file.path(project.dir, "data/CEDR/cedr_phyto_taxa.csv"),
                            data.table = FALSE,
                            colClasses = col.class.vec,
                            na.strings = "") %>% 

mutate(sampledate = as.Date(sampledate))

bay.df <- taxa.raw %>% 
  filter(layer %in% c("ap", "wc")) %>% 
  distinct() %>% 
  mutate(month = month(sampledate),
         season = case_when(
           month %in% c(3, 4, 5) ~ "spring",
           month %in% c(7, 8, 9) ~ "summer", 
           TRUE ~ "remove")) %>% 
  filter(season %in% c("spring", "summer")) %>%
  mutate(tsn=as.character(tsn)) %>%
  mutate(speccode = as.character(speccode)) %>%
  mutate(reportingvalue = as.integer(reportingvalue)) %>%
  mutate(samplenumber = as.character(samplenumber))

bay.df <- bay.df %>%
    mutate(size = case_when(size == "not_applicable"~ as.character(NA), TRUE ~ size))

bay.df <- bay.df %>% 
  group_by_at(vars(-reportingvalue)) %>% 
  summarize(reportingvalue = sum(reportingvalue)) %>% 
  ungroup()

bay.df <- bay.df %>% 
  filter(grepl("ph", method),
         !latinname %in% c("micro-phytoflagellates",
                           "microflagellates",
                           "epiphytic_flagellates",
                           "hydrodictyon_reticulatum"))
```
Update taxonomic serial numbers (TSNs, "tsn") for reported taxa ("latinname") that are known to be problematic. Most of these taxa are not in the Integrated Taxonomic Information System (ITIS) database, but an upstream taxonomic rank is available in ITIS. For example, the species, *Navicula notablis*, is not found in ITIS but the genus *Navicula* is present; therefore, the TSN and hierarchy for *Navicula* is used to represent an incomplete hierarchy for *Navicula notablis*. For the purposes of this IBI calcualtion, these incomplete hierarchies suffice because the metrics calculated do not require full taxonomic hierarchies.
```{r}
bay.df <- bay.df %>% 
  mutate(
    tsn = as.integer(tsn),
    tsn = case_when(
      latinname == "navicula_notablis" ~ as.integer(4327),
      latinname == "pleurosigma_macrum" ~ as.integer(4650),
      latinname == "pleurosigma_obscurum" ~ as.integer(591383),
      latinname == "polykrikos_hartmannii" ~ as.integer(331299),
      latinname == "protoperidinium_aciculiderum" ~ as.integer(10329),
      latinname == "protoperidinium_paulseni" ~ as.integer(3568),
      latinname == "scrippsiella_favionese" ~ as.integer(10537),
      latinname == "tetrastrum_caudatum" ~ as.integer(5691),
      latinname == "didymocystis" ~ as.integer(5810),
      latinname == "lauterborniella_elegantissima" ~ as.integer(6097),
      latinname == "characium_sp." ~ as.integer(5756),
      latinname == "cylindrospermopsis_sp." ~ as.integer(203689),
      latinname == "chaetoceros_neogracilis" ~ as.integer(1004011),
      latinname == "navicula_retusa_cancellata" ~ as.integer(1020372),
      latinname == "karlodinium_micrum" ~ as.integer(180904),
      latinname == "lagerheimia" ~ as.integer(6017),
      latinname == "quadricoccus_euryhalinicus" ~ as.integer(957939),
      latinname == "scrippsiella_precaria" ~ as.integer(10536),
      latinname == "psuedosolenia_calcar-avis" ~ as.integer(970064),
      latinname == "centronella" ~ as.integer(970064),
      latinname == "amphidinium_tatrae" ~ as.integer(9997),
      latinname == "navicula_lata" ~ as.integer(4450),
      latinname == "nitzschia_vitrea_recta" ~ as.integer(5204),
      latinname == "rhaphoneis_gemmifera" ~ as.integer(3145),
      latinname == "delphineis_surirella" ~ as.integer(969978),
      latinname == "navicula_annulata" ~ as.integer(3649),
      latinname == "proboscia_alata_gracillima" ~ as.integer(610099),
      latinname == "guinardia_striata" ~ as.integer(2921),
      latinname == "guinardia_cylindrus" ~ as.integer(2921),
      latinname == "aphanizomenon_issatschenkoi" ~ as.integer(1191),
      latinname == "helicotheca_tamesis" ~ as.integer(590815),
      latinname == "corethron_valdivae" ~ as.integer(2386),
      latinname == "gonyaulax_conjuncta" ~ as.integer(10359),
      latinname == "lioloma_delicatulum" ~ as.integer(573597),
      latinname == "syracosphaera_histrica" ~ as.integer(2234),
      latinname == "rhizosolenia_formosa" ~ as.integer(2879),
      latinname == "proboscla_alata_curvirostris" ~ as.integer(610099),
      latinname == "membraneis_challengeri" ~ as.integer(3648),
      latinname == "chrysococcus_tesselatus" ~ as.integer(1751),
      latinname == "rhoicosphenia_abbreviata" ~ as.integer(3633),
      latinname == "protoperidinium_aciculiferum" ~ as.integer(10340),
      latinname == "protoperidinium_fimbriatum" ~ as.integer(10340),
      latinname == "licmophora_inflata" ~ as.integer(3155),
      latinname == "biddulphia_reticulata" ~ as.integer(2678),
      latinname == "caloneis_lepidula" ~ as.integer(4369),
      latinname == "caloneis_trinodis" ~ as.integer(4369),
      latinname == "amphiprora_cholnokyi" ~ as.integer(4674),
      latinname == "navicula_interrupta" ~ as.integer(3649),
      latinname == "cerataulus_radiatus" ~ as.integer(2709),
      latinname == "gyrosigma_balticum_silimis" ~ as.integer(4623),
      latinname == "dictyocha_siderea" ~ as.integer(1804),
      latinname == "odontella_alternans" ~ as.integer(573604),
      latinname == "nitzschia_vitrea_salinarum" ~ as.integer(5204),
      latinname == "proboscla_alata_indica" ~ as.integer(610099),
      latinname == "attheya_decora" ~ as.integer(2876),
      latinname == "synedra_closterioides" ~ as.integer(970065),
      latinname == "trinacria_regina" ~ as.integer(2747),
      latinname == "chattonella" ~ as.integer(969917),
      latinname == "chattonella_subsalsa" ~ as.integer(969917),
      latinname == "heterosigma_akashiwo" ~ as.integer(969917),
      latinname == "vibrio_fisheri" ~ as.integer(959178),
      TRUE ~ as.integer(tsn)
    )
  )
```
Check for taxa with duplicate carbon values. If a taxon has two or more carbon values, it will be duplicated when `carbon.df` is joined with `bay.df`. Taxa with known duplicate carbon values include *biddulphia*, *chaetoceros wighami*, *gymnodinium*. One of the *chaetoceros wighami* `old_carbon` values is NA, and therefore, is excluded. The selected `old_carbon` values for *biddulphia* and *gymnodinium* appear to be the values used by (Lacouture et al. 2006). Then, identify all taxa in `bay.df` that do not have a size equivalent in `carbon.df` and try to find partial matches for taxa in `no.match.df`. Each row in `no.match.df` represents a unique taxon and size combination. The function,`lapply`, loops through each row, extracts the unique size string, splits the string into smaller pieces, and attempts to find partial matches with associated size strings in `carbon.df`. The string in `carbon.df` with the most partial matches will be used to replace the size string in `bay.df`.

Merge `bay.df` with `partial.match.df` and calculate biomass. Then, add the taxon, *Asterionellopsis glacialis* to `carbon.df` with the *Asterionellopsis kariana* carbon value and assign TSNs with NA a value of zero. Make changes in names of some taxa to match changes to the carbon list and remove columns that will be replaced with data from the `carbon.df` dataframe in the next step. 

Join `bay.df` and `carbon.df` before turning carbon NAs into zeroes and calculating `nano_micro_biomass`. Finally, merge the water quality dataframe with the main data.
```{r}
carbon.dups <- carbon.df %>% 
  group_by(latinname, size) %>% 
  mutate(count = n()) %>% 
  ungroup() %>% 
  filter(count > 1)

carbon.df <- carbon.df %>% 
  filter(!(latinname == "chaetoceros_wighami" & is.na(carbon)),
         !(latinname == "biddulphia" & carbon == 7899.50),
         !(latinname == "gymnodinium" & carbon == 848))

no.match.df <- anti_join(bay.df, carbon.df, by = c("latinname", "size")) %>% 
  select(latinname, size) %>% 
  distinct()

partial.match.df <- lapply(1:nrow(no.match.df), function(row.i) {
  sub.df <- no.match.df %>% 
    slice(row.i)
  
  size.vec <- str_split(sub.df$size, "_") %>% 
    unlist()
  
  getmode <- function(v) {
    uniqv <- unique(v)
    uniqv[which.max(tabulate(match(v, uniqv)))]
  }
  
  carbon.sub <- carbon.df %>% 
    filter(latinname == sub.df$latinname) %>% 
    mutate(row_max_matches = sapply(size.vec, function(size.i) grep(size.i, size)) %>% 
             unlist() %>% 
             getmode()) %>% 
    slice(unique(row_max_matches)) %>% 
    select(-row_max_matches, -carbon) %>% 
    rename(new_size = size) %>% 
    mutate(size = sub.df$size)
  
  return(carbon.sub)
}) %>% 
  bind_rows()

bay.df <- left_join(bay.df, partial.match.df, by = c("latinname", "size","tsn")) %>% 
  mutate(reported_size = size, size = if_else(!is.na(new_size), new_size, size))

carbon.df <- carbon.df %>%
  bind_rows(data.frame(latinname = "asterionellopsis_glacialis",
                       carbon = carbon.df[carbon.df$latinname == "asterionellopsis_kariana", "carbon"],
                       tsn = 615890,
                       group = "diatom",
                       stringsAsFactors = FALSE))

carbon.df <- carbon.df %>%
  mutate(tsn = ifelse(is.na(tsn)==TRUE, 0, tsn))

bay.df <- bay.df %>%
  mutate(latinname = ifelse(latinname=="protoperidinium_bipes", "minuscula_bipes", latinname)) %>%
  mutate(latinname = ifelse(latinname=="woronichinia_naegeliana", "coelosphaerium_naegelianum", latinname)) %>%
  mutate(latinname = ifelse(latinname=="centritractis_belonophorus", "centratractus_belonophorus", latinname)) %>%
  mutate(tsn = ifelse(tsn==10210, 10209, tsn)) %>%
  mutate(tsn = ifelse(latinname=="woronichinia_naegeliana", 0, tsn)) %>%
  mutate(tsn = ifelse(tsn==2014, 2013, tsn))

bay.df <- bay.df %>%
  select(-nodc_phyla, -group) 

bay_merged.df <- left_join(bay.df, carbon.df, by = c("latinname","size","tsn")) %>%
  distinct()

bay_merged.df <- bay_merged.df %>%
  mutate(carbon = ifelse(is.na(carbon)==TRUE, 0, carbon)) %>%
  mutate(nano_micro_biomass = reportingvalue * carbon / 10 ^ 6) 

bay_merged.df <-  bay_merged.df %>%
  mutate(concat = paste0(station, sampledate)) 

wq_final.df <- wq_final.df %>%
  mutate(concat = paste0(station, sampledate)) 

bay_wq_merged.df <- left_join(bay_merged.df, wq_final.df, by = c("concat", "station","sampledate", "month", "season"))
```
###**Metric Calculations**
Remove unnecessary columns and filter out salzone entries with NAs before calculating the metrics. Then, apply metrics to all applicable rows.
```{r}
bay_wq_merged_calc.df  <-  bay_wq_merged.df %>%

  mutate(unique_id = paste(station, layer, samplenumber, sampledate, sep = "_")) %>%
  select(-reported_size, -surveyid, -fieldactivityid, -source, -sampletype, -gmethod, -tsn, -size, -method, -parameter, -reportingunit, -nodccode, -serialnumber, -month, -new_size, -nodc_phyla, -speccode, -salinity) %>%
  
filter(!is.na(salzone)) %>%
  distinct() 

bay_wq_merged_calc.df <-  bay_wq_merged_calc.df  %>%
  group_by(unique_id) %>%
  mutate(total_nano_micro_biomass = sum(nano_micro_biomass, na.rm = T)) %>%
  mutate(carbon_chlorophyll_ratio = total_nano_micro_biomass/chla) %>%
  mutate(diatom_carbon = case_when(group == "diatom"~ nano_micro_biomass
                                    , TRUE ~ as.numeric(NA))) %>%
  mutate(diatom_biomass = case_when(!is.na(diatom_carbon)~ sum(diatom_carbon, na.rm = T)
                                    , TRUE ~ as.numeric(NA))) %>%
  mutate(dinoflagellate_carbon = case_when(group == "dinoflagellates"~ nano_micro_biomass
                                    , TRUE ~ as.numeric(NA))) %>%
  mutate(dinoflagellate_biomass = case_when(!is.na(dinoflagellate_carbon)~ sum(dinoflagellate_carbon, na.rm = T)
                                    , TRUE ~ as.numeric(NA))) %>%
  mutate(cyanophyte_carbon = case_when(group == "cyanophyte"| group == "cyanobacteria"~ nano_micro_biomass
                                    , TRUE ~ as.numeric(NA))) %>%
  mutate(cyanophyte_biomass = case_when(!is.na(cyanophyte_carbon)~ sum(cyanophyte_carbon, na.rm = T)
                                    , TRUE ~ as.numeric(NA))) %>%
  mutate(cryptophyte_carbon = case_when(group == "cryptophyte" | group == "cryptophyceae" | group == "cryptophyta" | group == "cryptomonads"~ nano_micro_biomass
                                    , TRUE ~ as.numeric(NA))) %>%
  mutate(cryptophyte_biomass = case_when(!is.na(cryptophyte_carbon)~ sum(cryptophyte_carbon, na.rm = T)
                                    , TRUE ~ as.numeric(NA))) %>%
  select(-diatom_carbon, -dinoflagellate_carbon, -cyanophyte_carbon, -cryptophyte_carbon) %>%
  mutate(percent_cryptophyte_biomass = cryptophyte_biomass/total_nano_micro_biomass * 100) %>% 
  mutate(other_biomass =(case_when(!group %in% c("cryptophyte","cryptophyceae","cryptophyta","cryptomonads", "cyanophyte","cyanobacteria", "dinoflagellates", "diatom"   ) ~ nano_micro_biomass, TRUE~0 )) ) %>%
  mutate(other_biomass_total = sum(other_biomass, na.rm = T)) %>%
  select(-group, -carbon, -nano_micro_biomass, -other_biomass) %>%
  ungroup() %>%
  distinct()

bay_wq_merged_calc.df <- bay_wq_merged_calc.df %>%
  group_by(unique_id) %>%
  mutate(prorocentrum_minimum_abundance = case_when(latinname == "prorocentrum_minimum"~ sum(as.double(reportingvalue)), TRUE ~ as.numeric(NA))) %>%
  mutate(microcystis_aeruginosa_abundance = case_when(latinname == "microcystis_aeruginosa"~ sum(as.double(reportingvalue)), TRUE ~ as.numeric(NA))) %>%
  mutate(prorocentrum_minimum_abundance = sum(prorocentrum_minimum_abundance, na.rm=T)) %>%
  mutate(microcystis_aeruginosa_abundance = sum(microcystis_aeruginosa_abundance, na.rm=T)) %>%
  ungroup() %>%
  select(-latinname, -reportingvalue) %>%
  distinct()

bay_wq_merged_calc.df[is.na(bay_wq_merged_calc.df)] <- 0

bay_wq_merged_calc.df <- bay_wq_merged_calc.df %>%
  group_by(unique_id) %>%
  mutate(diatom_biomass = max(diatom_biomass, na.rm=T)) %>%
  mutate(cyanophyte_biomass = max(cyanophyte_biomass, na.rm=T)) %>%
  mutate(dinoflagellate_biomass = max(dinoflagellate_biomass , na.rm=T)) %>%
  mutate(cryptophyte_biomass = max(cryptophyte_biomass, na.rm=T)) %>%
  mutate(percent_cryptophyte_biomass = max(percent_cryptophyte_biomass, na.rm=T)) %>%
  mutate(percent_cryptophyte_biomass =( case_when(percent_cryptophyte_biomass == "-inf"~as.numeric(NA), TRUE~percent_cryptophyte_biomass))) %>%
  distinct() %>%
  ungroup()
```
Run a test to determine if the biomasses are adding up correctly. Open the `test` dataframe, and if it is not empty, your biomasses aren't adding up correctly. Remove the `other_biomass_total` column before proceeding, then join the picoplankton data into the bay data. Average duplicates and generate picoplankton abundance.
```{r}
test <- bay_wq_merged_calc.df %>%
  mutate(biomass_total_test = (dinoflagellate_biomass + diatom_biomass +cryptophyte_biomass + cyanophyte_biomass + other_biomass_total)) %>%
  mutate(biomass_error =abs( total_nano_micro_biomass-biomass_total_test )) %>%
  filter( biomass_error > .00000001)

bay_wq_merged_calc.df <- bay_wq_merged_calc.df %>%
  select(-other_biomass_total)

picoplankton.df <- data.table::fread(file.path(project.dir, "data/CEDR/", "cedr_pico_taxa.csv")) %>% 
  clean_up() %>%
  rename(pico_reportingvalue = reportingvalue) %>%
  select("station", "sampledate", "pico_reportingvalue") %>% 
  mutate(sampledate=as.Date(sampledate)) %>%
  mutate(concat = paste0(station, sampledate)) %>%
  select(-"station",-"sampledate") %>%
  group_by(concat) %>%
  mutate(pico_reportingvalue = mean(pico_reportingvalue)) %>%
  mutate(picoplankton_abundance = sum(pico_reportingvalue)) %>%
  unique() %>%
  ungroup()

bay_full_calc.df <- left_join(bay_wq_merged_calc.df, picoplankton.df, by = c("concat"))
```
###**Scoring the metrics**
Rename some of the metrics to fit the following code and select only the relevant fields..
```{r}
metrics_prep.df <- bay_full_calc.df %>%
  rename(pheophytin = pheo) %>% 
  rename(total_nano_micro_biomass_chla_ratio = carbon_chlorophyll_ratio) %>%
  rename(pct_cryptophyte = percent_cryptophyte_biomass) %>%
  rename(surface_chla = s_chla) %>%
  mutate(salzone = tolower(salzone)) 

metrics_prep.df <- metrics_prep.df %>%
  select(unique_id, station, sampledate, samplenumber, season, salzone, total_nano_micro_biomass_chla_ratio,
                  surface_chla,
                  chla,
                  doc,
                  pheophytin,
                  total_nano_micro_biomass, 
                  diatom_biomass,
                  dinoflagellate_biomass,
                  cyanophyte_biomass,
                  cryptophyte_biomass,
                  pct_cryptophyte,
                  prorocentrum_minimum_abundance, 
                  microcystis_aeruginosa_abundance,
                  picoplankton_abundance) 
```
####**Score Spring, Fresh Water**
```{r}
score_spring_f <- metrics_prep.df %>% 
  filter(season == "spring",
         salzone == "f") %>%
  
  mutate(total_nano_micro_biomass_chla_ratio_score = case_when(
      total_nano_micro_biomass_chla_ratio < 39.28 ~ 1,
      total_nano_micro_biomass_chla_ratio >= 39.28 & total_nano_micro_biomass_chla_ratio <= 41.72 ~ 3,
      total_nano_micro_biomass_chla_ratio > 41.72 ~ 5,
      TRUE ~ as.numeric(NA))) %>%
  
  mutate(surface_chla_score = case_when(
      surface_chla < 3.42 | surface_chla > 14.45 ~ 1,
      (surface_chla >= 3.42 & surface_chla <= 4.37) | (surface_chla >= 13.98 & surface_chla <= 14.45) ~ 3,
      surface_chla > 4.37 & surface_chla < 13.98 ~ 5,
      TRUE ~ as.numeric(NA))) %>%
  
  mutate(cyanophyte_biomass_score = case_when(
      cyanophyte_biomass > 23.02 ~ 1,
      cyanophyte_biomass <= 23.02 ~ as.numeric(NA))) %>%
  
  mutate(doc_score = case_when(
      doc > 2.40 ~ 1,
      doc >= 2.19 & doc <= 2.40 ~ 3,
      doc  < 2.19 ~ 5,
      TRUE ~ as.numeric(NA))) %>%
  
  mutate(pheophytin_score = case_when(
      pheophytin > 2.50 ~ 1,
      pheophytin >= 1.55 & pheophytin <= 2.50 ~ 3,
      pheophytin < 1.55 ~ 5,
      TRUE ~ as.numeric(NA))) %>%
  
  mutate(total_nano_micro_biomass_score = case_when(
      total_nano_micro_biomass <= 172.99 | total_nano_micro_biomass > 828.5 ~ 1,
      total_nano_micro_biomass >= 583.9 & total_nano_micro_biomass <= 828.5 ~ 3,
      total_nano_micro_biomass > 172.99 & total_nano_micro_biomass < 583.9 ~ 5,
      TRUE ~ as.numeric(NA))) 
```
####**Score Spring, Oligohaline**
```{r}
score_spring_o <- metrics_prep.df %>% 
  filter(season == "spring",
         salzone == "o") %>%
  
  mutate(total_nano_micro_biomass_chla_ratio_score = case_when(
      total_nano_micro_biomass_chla_ratio < 18.8 | total_nano_micro_biomass_chla_ratio > 48.6 ~ 1,
      total_nano_micro_biomass_chla_ratio >= 18.8 & total_nano_micro_biomass_chla_ratio <= 21.2 ~ 3,
      total_nano_micro_biomass_chla_ratio > 21.2 & total_nano_micro_biomass_chla_ratio < 48.6 ~ 5,
      TRUE ~ as.numeric(NA))) %>%

  mutate(surface_chla_score = case_when(
      surface_chla < 6.77 | surface_chla > 33.64 ~ 1,
      (surface_chla >= 20.93 & surface_chla <= 33.64) | (surface_chla >= 6.77 & surface_chla <= 8.82) ~ 3,
      surface_chla > 8.82 & surface_chla < 20.93 ~ 5,
      TRUE ~ as.numeric(NA))) %>%

  mutate(doc_score = case_when(
      doc > 3.27 ~ 1,
      doc >= 2.69 & doc <= 3.27 ~ 3,
      doc < 2.69 ~ 5,
      TRUE ~ as.numeric(NA))) %>%

  mutate(pheophytin_score = case_when(
      pheophytin > 2.68 ~ 1,
      pheophytin >= 2.23 & pheophytin <= 2.68 ~ 3,
      pheophytin < 2.23 ~ 5,
    TRUE ~ as.numeric(NA))) %>%
  
  mutate(total_nano_micro_biomass_score = case_when(
      total_nano_micro_biomass < 131.37 | total_nano_micro_biomass >= 685.81 ~ 1,
      (total_nano_micro_biomass >= 131.37 & total_nano_micro_biomass <= 133.67) | (total_nano_micro_biomass >= 426.31 & total_nano_micro_biomass < 685.81) ~ 3,
      total_nano_micro_biomass > 133.67 & total_nano_micro_biomass < 426.31 ~ 5,
      TRUE ~ as.numeric(NA))) 
```
####**Score Spring, Mesohaline**  
```{r}
score_spring_m <- metrics_prep.df %>% 
  filter(
           season == "spring",
           salzone == "m") %>%
  
  mutate(total_nano_micro_biomass_chla_ratio_score = case_when(
      total_nano_micro_biomass_chla_ratio < 45.04 ~ 1,
      total_nano_micro_biomass_chla_ratio >= 45.04 & total_nano_micro_biomass_chla_ratio <= 69.52 ~ 3,
      total_nano_micro_biomass_chla_ratio > 69.52 ~ 5,
      TRUE ~ as.numeric(NA))) %>%
  
  mutate(surface_chla_score = case_when(
      surface_chla < 2.60 | surface_chla > 8.00 ~ 1,
      (surface_chla >= 2.60 & surface_chla <= 2.90) | (surface_chla >= 6.17 & surface_chla <= 8.00) ~ 3,
      surface_chla > 2.90 & surface_chla < 6.17 ~ 5,
      TRUE ~ as.numeric(NA))) %>%
  
  
  mutate(diatom_biomass_score = case_when(
      diatom_biomass < 149 | diatom_biomass >= 2513 ~ 1,
      diatom_biomass >= 149 & diatom_biomass <= 275.4 ~ 3,
      diatom_biomass > 275.4 & diatom_biomass < 2513 ~ 5,
      TRUE ~ as.numeric(NA))) %>%
  
  mutate(dinoflagellate_biomass_score = case_when(
      dinoflagellate_biomass < 28.3 | dinoflagellate_biomass > 268.2 ~ 1,
      dinoflagellate_biomass >= 156.9 & dinoflagellate_biomass <= 268.2 ~ 3,
      dinoflagellate_biomass > 28.3 & dinoflagellate_biomass < 156.9 ~ 5,
      TRUE ~ as.numeric(NA))) %>%
  
  mutate(doc_score = case_when(
      doc > 3.17 ~ 1,
      doc >= 2.84 & doc <= 3.17 ~ 3,
      doc < 2.84 ~ 5,
      TRUE ~ as.numeric(NA))) %>%
  
  mutate(pheophytin_score = case_when(
      pheophytin > 1.03 ~ 1,
      pheophytin >= 1.00 & pheophytin <= 1.03 ~ 3,
      pheophytin < 1.00 ~ 5,
      TRUE ~ as.numeric(NA))) %>%
  
  mutate(prorocentrum_minimum_abundance_score = case_when(
      prorocentrum_minimum_abundance > 1477600 ~ 1,
      prorocentrum_minimum_abundance <= 1477600 ~ as.numeric(NA),
      TRUE ~ as.numeric(NA))) %>%
  
  mutate(total_nano_micro_biomass_score = case_when(
      total_nano_micro_biomass > 1150 ~ 1,
      total_nano_micro_biomass <= 1150 ~ as.numeric(NA),
      TRUE ~ as.numeric(NA))) 
```
####**Score Spring, Polyhaline**
```{r}
score_spring_p <- metrics_prep.df %>% 
  filter(
           season == "spring",
           salzone == "p") %>%
  
  mutate(total_nano_micro_biomass_chla_ratio_score = case_when(
      total_nano_micro_biomass_chla_ratio < 71.0 ~ 1,
      total_nano_micro_biomass_chla_ratio >= 71.0 & total_nano_micro_biomass_chla_ratio <= 107.5 ~ 3,
      total_nano_micro_biomass_chla_ratio > 107.5 ~ 5,
      TRUE ~ as.numeric(NA))) %>%
  
  mutate(surface_chla_score = case_when(
      surface_chla > 4.00 ~ 1,
      surface_chla >= 2.80 & surface_chla <= 4.00 ~ 3,
      surface_chla < 2.80 ~ 5,
      TRUE ~ as.numeric(NA))) %>%
  
  mutate(pct_cryptophyte_score = case_when(
      pct_cryptophyte > 7.06 ~ 1,
      pct_cryptophyte >= 4.93 & pct_cryptophyte <= 7.06 ~ 3,
      pct_cryptophyte < 4.93 ~ 5,
      TRUE ~ as.numeric(NA))) %>%
  
  mutate(doc_score = case_when(
      doc > 2.61 ~ 1,
      doc >= 2.50 & doc <= 2.61 ~ 3,
      doc < 2.50 ~ 5,
      TRUE ~ as.numeric(NA))) %>%
  
  mutate(pheophytin_score = case_when(
      pheophytin > 0.90 ~ 1,
      pheophytin >= 0.55 & pheophytin <= 0.90 ~ 3,
      pheophytin < 0.55 ~ 5,
      TRUE ~ as.numeric(NA))) %>%
  
  mutate(prorocentrum_minimum_abundance_score = case_when(
      prorocentrum_minimum_abundance > 7488 ~ 1,
      prorocentrum_minimum_abundance >= 672 & prorocentrum_minimum_abundance <= 7488 ~ 3,
      prorocentrum_minimum_abundance < 672 ~ 5,
      TRUE ~ as.numeric(NA))) %>%
  
  mutate(total_nano_micro_biomass_score = case_when(
      total_nano_micro_biomass > 1061.7 ~ 1,
      total_nano_micro_biomass <= 1061.7 ~ as.numeric(NA),
      TRUE ~ as.numeric(NA))) 
  
```
####**Score Summer, Fresh Water**
```{r}
score_summer_f <- metrics_prep.df %>% 
  filter(
           season == "summer",
           salzone == "f") %>%
  
  mutate(surface_chla_score = case_when(
      surface_chla > 12.30 ~ 1,
      (surface_chla >= 12.00 & surface_chla <= 12.30) | surface_chla <= 5.4 ~ 3,
      surface_chla > 5.40 & surface_chla < 12.00 ~ 5,
      TRUE ~ as.numeric(NA))) %>%
  
  mutate(cyanophyte_biomass_score = case_when(
      cyanophyte_biomass > 67.4 ~ 1,
      cyanophyte_biomass >= 38.87 & cyanophyte_biomass <= 67.4 ~ 3,
      cyanophyte_biomass < 38.87 ~ 5,
      TRUE ~ as.numeric(NA))) %>%
  
  mutate(diatom_biomass_score = case_when(
      diatom_biomass > 192.6 ~ 1,
      diatom_biomass >= 122.1 & diatom_biomass <= 192.6 ~ 3,
      diatom_biomass < 122.1 ~ 5,
      TRUE ~ as.numeric(NA))) %>%
  
  mutate(doc_score = case_when(
      doc > 3.18 ~ 1,
      doc >= 2.67 & doc <= 3.18 ~ 3,
      doc < 2.67 ~ 5,
      TRUE ~ as.numeric(NA))) %>%
  
  mutate(microcystis_aeruginosa_abundance_score = case_when(
      microcystis_aeruginosa_abundance > 262507 ~ 1,
      microcystis_aeruginosa_abundance <= 262507 ~ as.numeric(NA),
      TRUE ~ as.numeric(NA))) %>%
  
  mutate(pheophytin_score = case_when(
      pheophytin > 4.30 ~ 1,
      pheophytin >= 2.40 & pheophytin <= 4.30 ~ 3,
      pheophytin < 2.40 ~ 5,
      TRUE ~ as.numeric(NA))) %>%
  
  mutate(total_nano_micro_biomass_score = case_when(
      total_nano_micro_biomass > 555.7 ~ 1,
      total_nano_micro_biomass < 231.3 ~ 3,
      total_nano_micro_biomass >= 231.3 & total_nano_micro_biomass <= 555.7 ~ 5,
      TRUE ~ as.numeric(NA))) 
```
####**Score Summer, Oligohaline**
```{r}
score_summer_o <- metrics_prep.df %>% 
  filter(season == "summer",
         salzone == "o") %>%
  
  mutate(surface_chla_score = case_when(
      surface_chla >= 9.47 ~ 1,
      surface_chla <= 4.20 ~ 3,
      surface_chla > 4.20 & surface_chla < 9.47 ~ 5,
      TRUE ~ as.numeric(NA))) %>%
  
  mutate(cyanophyte_biomass_score = case_when(
      cyanophyte_biomass >= 26.55 ~ 1,
      cyanophyte_biomass < 1.79 ~ 3,
      cyanophyte_biomass >= 1.79 & cyanophyte_biomass < 26.55 ~ 5,
      TRUE ~ as.numeric(NA))) %>%
  
  mutate(diatom_biomass_score = case_when(
      diatom_biomass >= 126.59 ~ 1,
      diatom_biomass <= 44.14 ~ 3,
      diatom_biomass > 44.14 & diatom_biomass < 126.59 ~ 5,
      TRUE ~ as.numeric(NA))) %>%
  
  mutate(doc_score = case_when(
      doc > 4.00 ~ 1,
      doc >= 3.15 & doc <= 4.00 ~ 3,
      doc < 3.15 ~ 5,
      TRUE ~ as.numeric(NA))) %>%
  
  mutate(pheophytin_score = case_when(
      pheophytin > 2.81 ~ 1,
      pheophytin >= 1.58 & pheophytin <= 2.81 ~ 3,
      pheophytin < 1.58 ~ 5,
      TRUE ~ as.numeric(NA))) 
```
####**Score Summer, Mesohaline**
```{r}
score_summer_m <- metrics_prep.df %>% 
  filter(season == "summer",
         salzone == "m") %>%
  
  mutate(total_nano_micro_biomass_chla_ratio_score = case_when(
      total_nano_micro_biomass_chla_ratio < 32.2 ~ 1,
      total_nano_micro_biomass_chla_ratio >= 32.2 & total_nano_micro_biomass_chla_ratio <= 36.9 ~ 3,
      total_nano_micro_biomass_chla_ratio > 36.9 ~ 5,
      TRUE ~ as.numeric(NA))) %>%

  mutate(surface_chla_score = case_when(
      surface_chla >= 9.74 ~ 1,
      (surface_chla >= 7.70 & surface_chla < 9.74) | surface_chla <= 4.00 ~ 3,
      surface_chla > 4.00 & surface_chla < 7.70 ~ 5,
      TRUE ~ as.numeric(NA))) %>%
  
  mutate(dinoflagellate_biomass_score = case_when(
      dinoflagellate_biomass <= 31.22 | dinoflagellate_biomass > 200.92 ~ 1,
      dinoflagellate_biomass > 31.22 & dinoflagellate_biomass<= 55.98 ~ 3, 
      dinoflagellate_biomass > 55.98 & dinoflagellate_biomass < 200.92 ~ 5,
      TRUE ~ as.numeric(NA))) %>%
  
  mutate(doc_score = case_when(
      doc > 3.35 ~ 1,
      doc >= 2.99 & doc <= 3.35 ~ 3,
      doc < 2.99 ~ 5,
      TRUE ~ as.numeric(NA))) %>%
  
  mutate(pheophytin_score = case_when(
      pheophytin > 1.60 ~ 1,
      pheophytin >= 1.23 & pheophytin <= 1.60 ~ 3,
      pheophytin < 1.23 ~ 5,
      TRUE ~ as.numeric(NA))) %>%
  
  mutate(picoplankton_abundance_score = case_when(
      picoplankton_abundance < 352000000 ~ 1,
      picoplankton_abundance >= 352000000 & picoplankton_abundance <= 598720000 ~ 3,
      picoplankton_abundance > 598720000 ~ 5,
      TRUE ~ as.numeric(NA))) %>%
  
  mutate(total_nano_micro_biomass_score = case_when(
      total_nano_micro_biomass > 660 ~ 1,
      total_nano_micro_biomass <= 660 ~ as.numeric(NA),
      TRUE ~ as.numeric(NA))) 
```
####**Score Summer, Polyhaline**
```{r}
score_summer_p <- metrics_prep.df %>% 
  filter(season == "summer",
         salzone == "p") %>%
  
  mutate(total_nano_micro_biomass_chla_ratio_score = case_when(
      total_nano_micro_biomass_chla_ratio < 37.7 ~ 1,
      total_nano_micro_biomass_chla_ratio >= 37.7 & total_nano_micro_biomass_chla_ratio <= 74.5 ~ 3,
      total_nano_micro_biomass_chla_ratio > 74.5 ~ 5,
      TRUE ~ as.numeric(NA))) %>%

  mutate(surface_chla_score = case_when(
      surface_chla > 5.33 ~ 1,
      surface_chla >= 4.52 & surface_chla <= 5.33 ~ 3,
      surface_chla < 4.52 ~ 5,
      TRUE ~ as.numeric(NA))) %>%
  
  mutate(pct_cryptophyte_score = case_when(
      pct_cryptophyte > 6.5 ~ 1,
      pct_cryptophyte >= 3.9 & pct_cryptophyte <= 6.5 ~ 3,
      pct_cryptophyte< 3.9 ~ 5,
      TRUE ~ as.numeric(NA))) %>%
  
  mutate(diatom_biomass_score = case_when(
      diatom_biomass >= 799 | diatom_biomass < 137 ~ 1,
      diatom_biomass >= 137 & diatom_biomass <= 181 ~ 3,
      diatom_biomass > 181 & diatom_biomass < 799 ~ 5,
      TRUE ~ as.numeric(NA))) %>%
  
  mutate(dinoflagellate_biomass_score = case_when(
      dinoflagellate_biomass < 23 | dinoflagellate_biomass >= 544 ~ 1,
      dinoflagellate_biomass >= 23 & dinoflagellate_biomass <= 37 ~ 3, 
      dinoflagellate_biomass > 37 & dinoflagellate_biomass < 554 ~ 5,
      TRUE ~ as.numeric(NA))) %>%
  
  mutate(doc_score = case_when(
      doc > 2.80 ~ 1,
      doc >= 2.58 & doc <= 2.80 ~ 3,
      doc < 2.58 ~ 5,
      TRUE ~ as.numeric(NA))) %>%
  
  mutate(pheophytin_score = case_when(
      pheophytin > 1.50 ~ 1,
      pheophytin >= 0.93 & pheophytin <= 1.50 ~ 3,
      pheophytin < 0.93 ~ 5,
      TRUE ~ as.numeric(NA))) %>%
  
  mutate(picoplankton_abundance_score = case_when(
      picoplankton_abundance < 208600000 ~ 1,
      picoplankton_abundance >= 208600000 & picoplankton_abundance <= 269500000 ~ 3,
      picoplankton_abundance > 269500000 ~ 5,
      TRUE ~ as.numeric(NA))) %>%
  
    mutate(total_nano_micro_biomass_score = case_when(
      total_nano_micro_biomass < 181 | total_nano_micro_biomass > 831 ~ 1,
      (total_nano_micro_biomass >= 181 & total_nano_micro_biomass <= 207) | (total_nano_micro_biomass >= 718 & total_nano_micro_biomass <= 831) ~ 3,
      total_nano_micro_biomass > 207 & total_nano_micro_biomass < 711 ~ 5,
      TRUE ~ as.numeric(NA))) 
```
###**Combine Scores**
Combine the scored metrics into one dataframe, `all_seasons`. Then, put it all together and generate the PIBI. Finish with replacing zero values in scores with blanks.
```{r}
all_seasons <- bind_rows(score_spring_f, score_spring_o ,score_spring_m, score_spring_p, score_summer_f, score_summer_o, score_summer_m, score_summer_p)

options(scipen=999)

all_seasons[is.na(all_seasons)] <- NA

scores_ratings_final <- all_seasons 

scores_ratings_final <- scores_ratings_final %>%
  
mutate(ibi_score = case_when(
  
season == "spring" & salzone == "f" ~ (rowMeans(subset(scores_ratings_final, select = c(total_nano_micro_biomass_chla_ratio_score, surface_chla_score, cyanophyte_biomass_score, doc_score, pheophytin_score, total_nano_micro_biomass_score)), na.rm = TRUE)),
                          
season == "spring" & salzone == "o" ~ (rowMeans(subset(scores_ratings_final, select = c(total_nano_micro_biomass_chla_ratio_score, surface_chla_score, doc_score, pheophytin_score, total_nano_micro_biomass_score)), na.rm = TRUE)),
                                 
season == "spring" & salzone == "m" ~ (rowMeans(subset(scores_ratings_final, select = c(total_nano_micro_biomass_chla_ratio_score, surface_chla_score, diatom_biomass_score, dinoflagellate_biomass_score, doc_score, pheophytin_score, prorocentrum_minimum_abundance_score, total_nano_micro_biomass_score)), na.rm = TRUE)),
                            
season == "spring" & salzone == "p" ~ (rowMeans(subset(scores_ratings_final, select = c(total_nano_micro_biomass_chla_ratio_score, surface_chla_score, pct_cryptophyte_score, doc_score, pheophytin_score, prorocentrum_minimum_abundance_score, total_nano_micro_biomass_score)), na.rm = TRUE)),
                                 
season == "summer" & salzone == "f" ~ (rowMeans(subset(scores_ratings_final, select = c(surface_chla_score, cyanophyte_biomass_score, diatom_biomass_score, doc_score, microcystis_aeruginosa_abundance_score, pheophytin_score, total_nano_micro_biomass_score)), na.rm = TRUE)),
                               
season == "summer" & salzone == "o" ~ (rowMeans(subset(scores_ratings_final, select = c(surface_chla_score, cyanophyte_biomass_score, diatom_biomass_score, doc_score, pheophytin_score)), na.rm = TRUE)),
                                 
season == "summer" & salzone == "m" ~ (rowMeans(subset(scores_ratings_final, select = c(total_nano_micro_biomass_chla_ratio_score, surface_chla_score, dinoflagellate_biomass_score, doc_score, pheophytin_score, picoplankton_abundance_score, total_nano_micro_biomass_score)), na.rm = TRUE)),
                                 
season == "summer" & salzone == "p" ~ (rowMeans(subset(scores_ratings_final, select = c(total_nano_micro_biomass_chla_ratio_score, surface_chla_score, pct_cryptophyte_score, diatom_biomass_score, dinoflagellate_biomass_score, doc_score, pheophytin_score, picoplankton_abundance_score, total_nano_micro_biomass_score)), na.rm = TRUE)),
     
TRUE~ 0)) 

scores_ratings_final[is.na(scores_ratings_final)] <- 0

scores_ratings_final <- scores_ratings_final %>%
  mutate_at(vars(ends_with("_score")), list(~case_when(.== 0 ~ " ", TRUE ~ as.character(.))))
```
###**Generate Ratings**
Generate ratings based on the scores. Ratings are `poor`, `fair_poor`, `fair`, `fair_good`, and `good`. Clean up the dataframe, rename some columns, and save the final scores to the "Scores/Ratings" folder within your directory.
```{r}
scores_ratings_final <- scores_ratings_final %>%
  mutate(
      rating = case_when(
        ibi_score < 2 ~ "poor",
        ibi_score >= 2 & ibi_score < 2.67 ~ "fair_poor",
        ibi_score >= 2.67 & ibi_score < 3.33 ~ "fair",
        ibi_score >= 3.33 & ibi_score < 4 ~ "fair_good",
        ibi_score >= 4 ~ "good",
        TRUE ~ "ERROR"))

scores_ratings_final <- scores_ratings_final %>%
  select(-chla) %>%
  select(-rating, rating) %>%
  select(-samplenumber) %>%
  rename(score_carbon_chlorophyll_ratio = total_nano_micro_biomass_chla_ratio_score) %>%
  rename(score_surface_chlorophyll = surface_chla_score) %>%
  rename(score_cyanophyte_biomass = cyanophyte_biomass_score) %>%
  rename(score_doc = doc_score) %>%
  rename(score_pheophytin = pheophytin_score) %>%
  rename(score_total_nano_micro_biomass = total_nano_micro_biomass_score) %>%
  rename(score_diatom_biomass = diatom_biomass_score) %>%
  rename(score_dinoflagellate_biomass = dinoflagellate_biomass_score) %>%
  rename(score_prorocentrum_minimum_abundance = prorocentrum_minimum_abundance_score) %>%
  rename(score_percent_cryptophyte_biomass = pct_cryptophyte_score) %>%
  rename(score_microcystis_aeruginosa_abundance = microcystis_aeruginosa_abundance_score) %>%
  rename(score_picoplankton_abundance = picoplankton_abundance_score)

scores_ratings_final %>% 
data.table::fwrite(file.path(project.dir, "data/ScoresRatings", "final_scores_ratings.csv"))
```
###**Citations**
Buchanan, Claire, Richard V. Lacouture, Harold G. Marshall, Marcia Olson, and Jacqueline M. Johnson. 2005. “Phytoplankton Reference Communities for Chesapeake Bay and Its Tidal Tributaries.” Estuaries and Coasts 28 (1): 138–59.

Lacouture, Richard V., Jacqueline M. Johnson, Claire Buchanan, and Harold G. Marshall. 2006. “Phytoplankton Index of Biotic Integrity for Chesapeake Bay and Its Tidal Tributaries.” Estuaries and Coasts 29 (4): 598–616.